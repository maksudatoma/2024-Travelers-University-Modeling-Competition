<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-11-16">

<title>Assignment - 6</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Assignment - 6_files/libs/clipboard/clipboard.min.js"></script>
<script src="Assignment - 6_files/libs/quarto-html/quarto.js"></script>
<script src="Assignment - 6_files/libs/quarto-html/popper.min.js"></script>
<script src="Assignment - 6_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Assignment - 6_files/libs/quarto-html/anchor.min.js"></script>
<link href="Assignment - 6_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Assignment - 6_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Assignment - 6_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Assignment - 6_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Assignment - 6_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Assignment - 6</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Maksuda Aktar Toma, Aarif Baksh </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 16, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The data is split into two parts: training data and validation data. In the validation data, the target variable, call_counts, is omitted.</p>
<p><strong>Variable Descriptions</strong></p>
<ul>
<li><p>ann_prm_amt: Annualized Premium Amount</p></li>
<li><p>bi_limit_group: Body injury limit group (SP stands for single split limit coverage, CSL stands for combined single limit coverage)</p></li>
<li><p>channel: Distribution channel</p></li>
<li><p>newest_veh_age: The age of the newest vehicle insured on a policy (-20 represents non-auto or missing values)</p></li>
<li><p>geo_group: Indicates if the policyholder lives in a rural, urban, or suburban area</p></li>
<li><p>has_prior_carrier: Did the policyholder come from another carrier</p></li>
<li><p>home_lot_sq_footage: Square footage of the policyholder’s home lot</p></li>
<li><p>household_group: The types of policy in household</p></li>
<li><p>household_policy_counts: Number of policies in the household</p></li>
<li><p>telematics_ind: Telematic indicator (0 represents auto missing values or didn’t enroll and -2 represents non-auto)</p></li>
<li><p>digital_contacts_ind: An indicator to denote if the policy holder has opted into digital communication</p></li>
<li><p>12m_call_history: Past one year call count</p></li>
<li><p>tenure_at_snapshot: Policy active length in month</p></li>
<li><p>pay_type_code: Code indicating the payment method</p></li>
<li><p>acq_mthd: The acquisition method (Miss represents missing values)</p></li>
<li><p>trm_len_mo: Term length month</p></li>
<li><p>pol_edeliv_ind: An indicator for email delivery of documents (-2 represents missing values)</p></li>
<li><p>product_sbtyp_grp: Product subtype group</p></li>
<li><p>product_sbtyp: Product subtype</p></li>
<li><p>call_counts: The number of call count generated by each policy (target variable)</p></li>
</ul>
</section>
<section id="data-cleaning-and-missing-value-count" class="level2">
<h2 class="anchored" data-anchor-id="data-cleaning-and-missing-value-count">Data Cleaning and Missing Value count</h2>
<p>First, we prepares the data by cleaning and transforming it (e.g., converting characters to factors, marking missing values). Then, analyzes the extent of missing data, calculates the percentage of zeros in the response variable (call_counts), which is important for modeling or imputation strategies.</p>
<p><strong>These variables show the number of missing values:</strong> acq_method: 16,066 missing values. newest_veh_age: 58,015 missing values. pol_edeliv_ind: 838 missing values. telematics_ind: 58,015 missing values</p>
<p><strong>Zero Values:</strong> 50.18% of the rows in the call_counts column are zeros, indicating that most customers made no calls. This is significant and might suggest using models like Zero-Inflated Poisson (ZIP) to handle the high frequency of zeros.</p>
<p><strong>Key Takeaways</strong> - The dataset contains both numeric and categorical variables, with some columns having significant missing values. - The target variable (call_counts) is heavily zero-inflated and skewed, which may require specialized modeling approaches. - Some numeric variables, like ann_prm_amt and home_lot_sq_footage, have wide ranges and outliers, suggesting that data transformation or scaling may be beneficial.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>    acq_method newest_veh_age pol_edeliv_ind telematics_ind 
         16066          58015            838          58015 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 50.18</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<p><img src="Assignment---6_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="missing-value-display" class="level2">
<h2 class="anchored" data-anchor-id="missing-value-display">Missing Value display</h2>
<ol type="1">
<li>This UpSet Plot shows the patterns and extent of missing data across variables. The horizontal bars on the left represent the total missing values for each variable, with newest_veh_age and telematics_ind having the most missing data. The vertical bars represent the number of rows with specific missingness patterns, with the tallest bar (~45,731 rows) indicating that only newest_veh_age has missing values. The connected dots below highlight combinations of missingness across variables, with fewer rows having simultaneous missing values in multiple variables. This analysis suggests focusing on simple imputation for variables with isolated missingness and predictive modeling for overlapping patterns</li>
</ol>
<div class="cell">
<div class="cell-output-display">
<p><img src="Assignment---6_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<ol start="2" type="1">
<li>This chart shows the percentage and count of missing values for each feature in the dataset. Most features (green bars) have no missing data, making them ready for modeling. However, newest_veh_age and telematics_ind have significant missingness (72.52%), requiring advanced imputation or removal. acq_method has moderate missingness (20.08%), which can be addressed with simpler imputation methods. Features like pol_edeliv_ind (1.05% missing) require minimal effort to handle, such as mean or mode imputation. The focus should be on addressing features with high and moderate missingness to ensure data quality for modeling.</li>
</ol>
<div class="cell">
<div class="cell-output-display">
<p><img src="Assignment---6_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>3.This visualization highlights missing data patterns in the dataset. The left panel shows that telematics_ind and newest_veh_age have the highest proportion of missing values (~70%), while pol_edeliv_ind has a smaller proportion (~10%). The right panel reveals that most rows have no missing data (blue squares), but missingness in telematics_ind and newest_veh_age often co-occurs. Other features have negligible or no missing data. It is recommended to either impute or exclude telematics_ind and newest_veh_age depending on their importance, while simpler imputation methods can handle pol_edeliv_ind.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Assignment---6_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
 Variables sorted by number of missings: 
                Variable     Count
          newest_veh_age 0.7251875
          telematics_ind 0.7251875
              acq_method 0.2008250
          pol_edeliv_ind 0.0104750
       X12m_call_history 0.0000000
             ann_prm_amt 0.0000000
          bi_limit_group 0.0000000
                 channel 0.0000000
     digital_contact_ind 0.0000000
               geo_group 0.0000000
       has_prior_carrier 0.0000000
     home_lot_sq_footage 0.0000000
         household_group 0.0000000
 household_policy_counts 0.0000000
           pay_type_code 0.0000000
         prdct_sbtyp_grp 0.0000000
           product_sbtyp 0.0000000
      tenure_at_snapshot 0.0000000
              trm_len_mo 0.0000000
             call_counts 0.0000000</code></pre>
</div>
</div>
</section>
<section id="correlation-structure" class="level2">
<h2 class="anchored" data-anchor-id="correlation-structure">Correlation Structure</h2>
<p>The correlations output show that X12m_call_history (r=0.28) is the strongest numeric predictor of call_counts, with a moderate positive relationship. Other variables like telematics_ind (𝑟=0.0059) and pol_edeliv_ind (𝑟=0.0049) have very weak positive correlations, while variables like household_policy_counts (r=−0.0033) and newest_veh_age (r=−0.0030) have negligible negative correlations. Most numeric variables show correlations close to zero, suggesting little to no linear relationship with the target variable. Overall, X12m_call_history is the most promising numeric predictor, while others may require further evaluation for relevance in modeling.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>      X12m_call_history             ann_prm_amt     digital_contact_ind 
           0.2799527640            0.0009293953            0.0026141348 
      has_prior_carrier     home_lot_sq_footage household_policy_counts 
           0.0005052426            0.0009486643           -0.0033470952 
         newest_veh_age          pol_edeliv_ind          telematics_ind 
          -0.0030184309            0.0048667762            0.0058867474 
     tenure_at_snapshot              trm_len_mo             call_counts 
          -0.0014746341            0.0007817227            1.0000000000 </code></pre>
</div>
</div>
<p><strong>Correlation Matrix:</strong> The correlation heatmap shows that X12m_call_history has the strongest positive correlation (r≈0.28) with call_counts, making it the most important numeric predictor. Most other variables, such as ann_prm_amt, household_policy_counts, and home_lot_sq_footage, have weak or no significant correlations with the target variable, as indicated by grey cells. There are no strong negative correlations in the dataset. Overall, the relationships are mostly weak, suggesting that non-linear models or feature engineering may be needed to capture more complex interactions. The heatmap helps identify X12m_call_history as a key feature while others may contribute less linearly.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Assignment---6_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="anova" class="level2">
<h2 class="anchored" data-anchor-id="anova">Anova</h2>
<p>The ANOVA results evaluate the effect of categorical variables on call_counts. Among the predictors, acq_method is marginally significant (p=0.0518), suggesting it may have a weak influence on call_counts. All other categorical variables, such as bi_limit_group, channel, and geo_group, have p-values greater than 0.1, indicating no statistically significant relationship with the target variable. Additionally, 16,066 rows were excluded due to missing data, which might affect the robustness of the results. It is recommended to focus on acq_method for further analysis and consider handling missing data to improve model accuracy.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>$acq_method
               Df   Sum Sq Mean Sq F value Pr(&gt;F)  
trav[[var]]     3    11110    3703   2.579 0.0518 .
Residuals   63930 91805237    1436                 
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
16066 observations deleted due to missingness

$bi_limit_group
               Df    Sum Sq Mean Sq F value Pr(&gt;F)
trav[[var]]     7      2207   315.3    0.22  0.981
Residuals   79992 114719475  1434.1               

$channel
               Df    Sum Sq Mean Sq F value Pr(&gt;F)
trav[[var]]     1       146   146.2   0.102   0.75
Residuals   79998 114721536  1434.1               

$geo_group
               Df    Sum Sq Mean Sq F value Pr(&gt;F)
trav[[var]]     2      5412    2706   1.887  0.152
Residuals   79997 114716270    1434               

$household_group
               Df    Sum Sq Mean Sq F value Pr(&gt;F)
trav[[var]]     3      2624   874.7    0.61  0.608
Residuals   79996 114719058  1434.1               

$pay_type_code
               Df    Sum Sq Mean Sq F value Pr(&gt;F)
trav[[var]]     2       117    58.7   0.041   0.96
Residuals   79997 114721565  1434.1               

$prdct_sbtyp_grp
               Df    Sum Sq Mean Sq F value Pr(&gt;F)
trav[[var]]     2      1861   930.6   0.649  0.523
Residuals   79997 114719821  1434.1               

$product_sbtyp
               Df    Sum Sq Mean Sq F value Pr(&gt;F)
trav[[var]]     2       117    58.7   0.041   0.96
Residuals   79997 114721565  1434.1               </code></pre>
</div>
</div>
<p><strong>Call_counts distribution with significant predictor</strong> [Note: Should keep only one] The violin plot shows the distribution of call_counts across different acquisition methods (acq_method). All methods have a heavily skewed distribution, with most values near 0 and a few extreme outliers, indicating that the majority of customers make few calls. The distributions are nearly identical across all methods, including the NA category, suggesting that acq_method has minimal impact on call_counts. This aligns with the ANOVA results, where acq_method was marginally significant. Further analysis, such as handling outliers or exploring interactions with other variables, may provide additional insights.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="Assignment---6_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output-display">
<p><img src="Assignment---6_files/figure-html/unnamed-chunk-9-2.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output-display">
<p><img src="Assignment---6_files/figure-html/unnamed-chunk-9-3.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="splitting-dataset" class="level2">
<h2 class="anchored" data-anchor-id="splitting-dataset">Splitting Dataset</h2>
<p>Before diiging with the model fit we’ll split the data set.The dataset splits into training (60%), validation (20%), and test (20%) sets, ensuring stratification of the call_counts variable. Stratification preserves the distribution of call_counts across all subsets, confirmed by the nearly identical means of the subsets. The training set is used to build the model, the validation set is used for tuning and performance assessment during training, and the test set is reserved for final evaluation. This ensures unbiased and representative splits for reliable model training and testing.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] 25.93654</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 25.88844</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 25.85405</code></pre>
</div>
</div>
</section>
<section id="model" class="level2">
<h2 class="anchored" data-anchor-id="model">Model</h2>
<p><strong>Model - 1:</strong> GBM We trained a GBM model using 500 trees with a Poisson distribution to predict call_counts. The model achieved an RMSE of 36.06, indicating moderate prediction error, suggesting the predictions deviate by about 36 calls on average from actual values. This result highlights potential room for improvement, such as hyperparameter tuning (e.g., adjusting n.tree, interaction.depth, or shrinkage), feature engineering, or handling outliers in the data. Comparing this RMSE with other models can help identify the best-performing approach.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] 36.05584</code></pre>
</div>
</div>
<p><strong>Model - 2:</strong> ZIP The Zero-Inflated Poisson (ZIP) model predicts call_counts while accounting for excess zeros. In the count model, X12m_call_history and prdct_sbtyp_grp significantly influence the count of call_counts, with higher X12m_call_history associated with increased counts. In the zero-inflation model, X12m_call_history reduces the likelihood of excess zeros, while prdct_sbtyp_grp has no significant effect on zero counts. The model effectively handles the over-representation of zeros and identifies X12m_call_history as a key predictor for both count and zero-inflation processes. Further evaluation against simpler models (e.g., Poisson) or adding more predictors may enhance its performance.</p>
<p>```{r-2, echo=FALSE}</p>
<p>#Method 2 - ZIP</p>
<p>library(pscl)</p>
</section>
<section id="zero-inflated-poisson-model" class="level1">
<h1>Zero-Inflated Poisson model</h1>
<p>zip_model &lt;- zeroinfl(call_counts ~ X12m_call_history+prdct_sbtyp_grp, data = train_data, dist = “poisson”)</p>
<p>summary(zip_model)</p>
<pre><code>\newpage

# Appendix A - R Code
[Haven't put all codes]


::: {.cell}

```{.r .cell-code}
library(caret)
library(dplyr)
library(mice)
trav &lt;- read.csv("train_data.csv")

#Exclude first column (ID column)
trav &lt;- trav[,-1]

trav &lt;- trav %&gt;%
  mutate(across(where(is.character), as.factor))

trav[trav == -2 |trav == -20 | trav == "missing"] &lt;- NA

missing_counts &lt;- colSums(is.na(trav))

# Display variables with missing values and their counts
missing_counts[missing_counts &gt; 0]

#Zero values for the response
per0resp &lt;- sum(trav$call_counts == 0) / nrow(trav) * 100
per0resp</code></pre>
<p>:::</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>